import groovy.json.JsonBuilder
import groovy.json.JsonOutput
import nz.govt.natlib.tools.sip.generation.parameters.Spreadsheet
import nz.govt.natlib.tools.sip.generation.parameters.SpreadsheetImporter
import nz.govt.natlib.m11n.tools.gradle.BuildException
import nz.govt.natlib.m11n.tools.gradle.ProjectHelper

import java.nio.charset.StandardCharsets

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath 'nz.govt.natlib.m11n.tools:gradle-plugin:1.0.0-SNAPSHOT'
        classpath 'nz.govt.natlib.tools:sip-generation-gradle-plugin:1.0.0-SNAPSHOT'
    }
}

plugins {
    // required for jacoco test coverage checks
    id 'com.github.kt3k.coveralls' version '2.6.3'
}

project.ext {
    // TODO Will need tasks associated with jacoco to actually use these limits
    // TODO Generally the goal here is to have code coverage in the 80--90% range
    // but it may be better to approach this with a more directed focus
    // (i.e. increase code coverage when new functionality is added)
    // TODO Write unit tests!
    codeCoverageLimits = [
            'instruction': 0.0, // currently at 0.0%
            'branch'     : 0.0, // currently at 0.0%
            'line'       : 0.0, // currently at 0.0%
            'complexity' : 0.0, // currently at 0.0%
            'method'     : 0.0, // currently at 0.0%
            'class'      : 0.0  // currently at 0.0%
    ]

    String coreResourcePath = "core/src/main/resources/nz/govt/natlib/tools/sip/generation/fairfax/".replace("/", File.separator)
    // Command-line variables used for specific tasks
    // Task updateDefaultFairfaxImportParameters
    doUpdateDefaultFairfaxImportParameters = ProjectHelper.hasAnyTasks(project, [ "updateDefaultFairfaxImportParameters" ])
    fairfaxSpreadsheetImportFilenameValue = project.hasProperty('fairfaxSpreadsheetImportFilename') ?
            project.fairfaxSpreadsheetImportFilename : null
    fairfaxSpreadsheetExportFilenameValue = project.hasProperty('fairfaxSpreadsheetExportFilename') ?
            project.fairfaxSpreadsheetExportFilename : "${coreResourcePath}default-fairfax-import-parameters.json"

    // Task updateDefaultFairfaxImportParameters
    doExportDefaultFairfaxImportParameters = ProjectHelper.hasAnyTasks(project, [ "exportDefaultFairfaxImportParameters" ])
    fairfaxSpreadsheetExportFilenameValue = project.hasProperty('fairfaxSpreadsheetExportFilename') ?
            project.fairfaxSpreadsheetExportFilename : null

    fairfaxSpreadsheetImportFilenameValue = null
    defaultExportFilename = ""
    if (doUpdateDefaultFairfaxImportParameters) {
        defaultExportFilename = "default-fairfax-import-parameters.json"
        fairfaxSpreadsheetImportFilenameValue = project.hasProperty('fairfaxSpreadsheetImportFilename') ?
                project.fairfaxSpreadsheetImportFilename : null
    } else if (doExportDefaultFairfaxImportParameters) {
        defaultExportFilename = "fairfax-export-parameters.csv"
        fairfaxSpreadsheetImportFilenameValue = project.hasProperty('fairfaxSpreadsheetImportFilename') ?
                project.fairfaxSpreadsheetImportFilename :
                "${coreResourcePath}default-fairfax-import-parameters.json"
    }
    fairfaxSpreadsheetExportFilenameValue = project.hasProperty('fairfaxSpreadsheetExportFilename') ?
            project.fairfaxSpreadsheetExportFilename :
            "${coreResourcePath}${defaultExportFilename}"
}

apply plugin: 'groovy'

apply plugin: 'java'

// this needs to be set after the 'java' plugin has been applied
java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}

apply plugin: 'jacoco'
jacoco {
    // This version is necessary to run under JDK 1.11
    toolVersion = "0.8.2"
}

// run the findBugs checks with 'gradle check' or 'gradle findBugsMain' or 'gradle findBugsTest'
//apply plugin: 'findbugs'

// run the pmd source code analyzer with 'gradle check' or 'gradle pmdMain' or 'gradle pmdTest'
apply plugin: 'pmd' // source code analyzer

setVersion(project.ext.versionNumber)

dependencies {
    // localGroovy (which is currently 2.4.x) is used. Groovy 2.5.x supports JsonGenerator and other new functionality
    // but causes issues with downstream builds, so alternatives provided by Groovy 2.4.x are used.
    compile localGroovy()
    //compile 'org.codehaus.groovy:groovy-all:2.5.4'

    // Latest version
    compile "org.apache.commons:commons-lang3:3.9"
    // Latest version
    compile "org.apache.commons:commons-collections4:4.3"

    // For parallel processing
    compile "org.codehaus.gpars:gpars:1.2.1"

    // We're using Log4j2
    compile 'org.apache.logging.log4j:log4j-api:2.11.2'
    compile 'org.apache.logging.log4j:log4j-core:2.11.2'
    // Ensure that other logging APIs use log4j2
    compile 'org.apache.logging.log4j:log4j-slf4j-impl:2.11.2'
    compile 'org.apache.logging.log4j:log4j-jcl:2.11.2'

    compile 'nz.govt.natlib.tools:sip-generation-core:1.0.0-SNAPSHOT'

    // latest version
    testCompile 'junit:junit:4.12'

    // latest version
    testCompile 'org.hamcrest:hamcrest-core:2.1'

    // latest version
    testCompile 'org.mockito:mockito-core:2.23.4'
}

jar {
    includeEmptyDirs = false
}

task jarSources(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    includeEmptyDirs = false

    from sourceSets.main.allSource
}

task updateDefaultFairfaxImportParameters() {
    File spreadsheetImportFile
    if (project.doUpdateDefaultFairfaxImportParameters) {
        if (project.fairfaxSpreadsheetImportFilenameValue == null) {
            throw new BuildException("fairfaxSpreadsheetImportFilename=${project.fairfaxSpreadsheetImportFilenameValue} must be set when calling task 'updateDefaultFairfaxImportParameters'.".toString())
        } else {
            spreadsheetImportFile = new File((String) project.fairfaxSpreadsheetImportFilenameValue)
        }
        if (!spreadsheetImportFile.exists()) {
            throw new BuildException("File=${spreadsheetImportFile.getCanonicalPath()} must exist.".toString())
        }
        if (!spreadsheetImportFile.isFile()) {
            throw new BuildException("File=${spreadsheetImportFile.getCanonicalPath()} must be a file.".toString())
        }
    }
    doLast {
        File spreadsheetExportFile = new File(project.fairfaxSpreadsheetExportFilenameValue)
        logger.info("Writing spreadsheet-import-file=${spreadsheetImportFile.getCanonicalPath()} to spreadsheet-export-file=${spreadsheetExportFile.getCanonicalPath()}")
        boolean allowDuplicateIds = true
        boolean allowRowsWithoutIds = true
        // TODO Make the separator configurable
        // Note that the MMSID is not unique for each row, so we generate an id for each row
        Spreadsheet spreadsheet = SpreadsheetImporter.extractSpreadsheet(spreadsheetImportFile, "GENERATE_ID_VALUE", "|", allowDuplicateIds, allowRowsWithoutIds)
        logger.info("spreadsheet values imported:")
        spreadsheet.rows.each { Map<String, String> spreadsheetLine ->
            StringBuilder line = new StringBuilder()
            spreadsheetLine.each { String key, String value ->
                line.append("${key}:${value}|")
            }
            logger.info(line.toString())
        }
        JsonBuilder jsonBuilder = new JsonBuilder()

        spreadsheetExportFile.withWriter(StandardCharsets.UTF_8.name()) { Writer writer ->
            writer.write(JsonOutput.prettyPrint(spreadsheet.asJsonString()))
        }
    }
}

// Export the fairfax import parameters JSON as a CSV spreadsheet
task exportDefaultFairfaxImportParameters() {
    File spreadsheetImportFile
    if (project.doExportDefaultFairfaxImportParameters) {
        if (project.fairfaxSpreadsheetImportFilenameValue == null) {
            throw new BuildException("fairfaxSpreadsheetImportFilename=${project.fairfaxSpreadsheetImportFilenameValue} must be set when calling task 'exportDefaultFairfaxImportParameters'.".toString())
        } else {
            spreadsheetImportFile = new File((String) project.fairfaxSpreadsheetImportFilenameValue)
        }
        if (!spreadsheetImportFile.exists()) {
            throw new BuildException("File=${spreadsheetImportFile.getCanonicalPath()} must exist.".toString())
        }
        if (!spreadsheetImportFile.isFile()) {
            throw new BuildException("File=${spreadsheetImportFile.getCanonicalPath()} must be a file.".toString())
        }
    }
    doLast {
        File spreadsheetExportFile = new File(project.fairfaxSpreadsheetExportFilenameValue)
        logger.info("Writing spreadsheet-import-file=${spreadsheetImportFile.getCanonicalPath()} to spreadsheet-export-file=${spreadsheetExportFile.getCanonicalPath()}")
        boolean allowDuplicateIds = true
        boolean allowRowsWithoutIds = true
        // TODO Make the separator configurable
        // Note that the MMSID is not unique for each row, so we generate an id for each row
        Spreadsheet spreadsheet = Spreadsheet.fromJson("GENERATE_ID_VALUE", spreadsheetImportFile, allowDuplicateIds, allowRowsWithoutIds)
        logger.info("spreadsheet values imported:")
        spreadsheet.rows.each { Map<String, String> spreadsheetLine ->
            StringBuilder line = new StringBuilder()
            spreadsheetLine.each { String key, String value ->
                line.append("${key}:${value}|")
            }
            logger.info(line.toString())
        }

        spreadsheetExportFile.withWriter(StandardCharsets.UTF_8.name()) { Writer writer ->
            writer.write(spreadsheet.asCsvString("|"))
        }
    }
}

test {
    testLogging.showStandardStreams = true
    testLogging.exceptionFormat = 'full'
}

//tasks.withType(FindBugs) {
//    // Unfortunately FindBugs will find a lot of problems with Groovy classes. We could filter out groovy source files,
//    // but since FindBugs operates on .class files, that filtering will be ineffective. Currently there are no java
//    // classes but that could change in the future.
//    // See https://stackoverflow.com/questions/22037499/using-excludes-config-in-findbugs-and-checkstyle-plugin-in-gradle
//    // In order for Java classes to see Groovy classes easily, we compile them all together with the Groovy compiler
//    // in the same source tree (src/main/groovy). This means we can't use the path to determine if the .class file
//    // came from a Groovy or Java source. The net effect is that FindBugs won't work with a mixed heritage of
//    // Java and Groovy classes. So we remove the FindBugs plugin for now.
//    exclude '**/*.groovy'
//    classes = classes.filter {
//        !(it.path.contains(new File("classes/groovy/main").path) || it.path.contains(new File("classes/groovy/test").path))
//    }
//}

// We want to force a specific version as part of our dependency resolution
//configurations.all {
//    resolutionStrategy {
//        force 'org.codehaus.groovy:groovy-all:2.4.+'
//    }
//}

artifacts {
    publishableArtifacts jar, jarSources
}

publishing {
    publications {
        maven(MavenPublication) {
            from components.java
            artifact tasks.jarSources
        }
    }

    repositories {
        maven {
            mavenLocal()
        }
    }
}

build.dependsOn jar, jarSources
